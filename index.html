<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mapa de Espa√±a ‚Äî Puzzle Provincias</title>
  <style>
    body{margin:0;background:#f5f7ff;font-family:system-ui,sans-serif;display:flex;justify-content:center}
    .wrap{width:min(1200px,96vw);padding:16px}
    header{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{background:#eef2ff;border:1px solid #c7d2fe;border-radius:12px;padding:6px 12px}
    button{border:0;border-radius:10px;padding:8px 12px;cursor:pointer}
    .btn1{background:#f97316;color:#fff}
    .btn2{background:#ef4444;color:#fff}
    .grid{display:grid;grid-template-columns: 1.3fr .7fr; gap:14px; margin-top:14px}
    @media (max-width: 900px){ .grid{grid-template-columns:1fr} }

    .card{background:#fff;border-radius:16px;box-shadow:0 10px 25px rgba(0,0,0,.08);padding:12px}
    #stage{width:100%;height:min(75vh,720px);border-radius:16px;overflow:hidden}
    #stage svg{width:100%;height:100%;display:block}

    .slot{fill:#e5e7eb;stroke:#9ca3af;stroke-width:1.2;stroke-dasharray:6 6;pointer-events:none}
    .piece{fill:#3b82f6;stroke:#1e40af;stroke-width:1.2;cursor:grab;transition:transform .12s ease}
    .piece.dragging{cursor:grabbing;opacity:.85}
    .piece.placed{pointer-events:none;cursor:default;filter: drop-shadow(0 2px 4px rgba(0,0,0,.15));}

    .hint{color:#374151;margin:8px 0 0}
    .list{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
    .chip{border:1px solid #bfdbfe;background:#eff6ff;border-radius:999px;padding:6px 10px;font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="pill"><b>Zona:</b> <span id="zone">Espa√±a (provincias)</span></div>
      <div class="pill"><b>Progreso:</b> <span id="prog">0</span>/<span id="total">0</span></div>
      <button class="btn1" id="shuffle">Ordenar piezas</button>
      <button class="btn2" id="reset">Reiniciar</button>
    </header>

    <div class="grid">
      <div class="card" id="stage">
        <!-- Aqu√≠ se carga el SVG real -->
        <div id="loading" style="padding:12px;color:#374151">Cargando mapa real‚Ä¶</div>
      </div>

      <div class="card">
        <b>Piezas disponibles</b>
        <div class="hint">
          Arrastra cada provincia y su√©ltala cerca de su hueco. Si est√° lo bastante cerca, encaja sola.
          <br><br>
          ‚ö†Ô∏è Para que funcione, tu <code>spain-provinces.svg</code> debe tener IDs o <code>data-province</code> por provincia.
        </div>
        <div class="list" id="chips"></div>
        <div class="hint" style="margin-top:10px">
          Si al arrastrar ‚Äúno engancha‚Äù, sube el umbral SNAP o revisa los ids del SVG.
        </div>
      </div>
    </div>
  </div>

<script>
(async function(){
  const STAGE = document.getElementById("stage");
  const LOADING = document.getElementById("loading");
  const PROG = document.getElementById("prog");
  const TOTAL = document.getElementById("total");
  const CHIPS = document.getElementById("chips");

  const SNAP_DISTANCE = 18; // aumenta a 25‚Äì35 si quieres encaje m√°s f√°cil
  const placed = new Set();

  // 1) Cargar SVG real local
  const res = await fetch("./spain-provinces.svg");
  const svgText = await res.text();
  LOADING?.remove();

  // Insertar SVG en el stage
  STAGE.insertAdjacentHTML("beforeend", svgText);
  const svg = STAGE.querySelector("svg");
  if(!svg) {
    STAGE.innerHTML = "<div style='padding:12px;color:#b91c1c'>No se encontr√≥ un &lt;svg&gt; dentro de spain-provinces.svg</div>";
    return;
  }

  // Asegurar viewBox (si el SVG no lo trae, muchos c√°lculos fallan)
  if(!svg.getAttribute("viewBox")) {
    const w = svg.getAttribute("width") || 1000;
    const h = svg.getAttribute("height") || 1000;
    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
  }

  // 2) Detectar provincias del SVG
  // Opci√≥n A: el SVG ya trae data-province
  let provinceEls = Array.from(svg.querySelectorAll("[data-province]"));

  // Opci√≥n B: si trae ids por provincia (ej: id="madrid"), los convertimos a data-province
  if(provinceEls.length === 0) {
    const candidates = Array.from(svg.querySelectorAll("path[id], g[id]"))
      .filter(el => el.id && !["board","pieces"].includes(el.id));
    candidates.forEach(el => el.setAttribute("data-province", el.id));
    provinceEls = Array.from(svg.querySelectorAll("[data-province]"));
  }

  if(provinceEls.length === 0) {
    STAGE.insertAdjacentHTML("beforeend",
      "<div style='padding:12px;color:#b91c1c'>Tu SVG no tiene provincias con <b>id</b> ni <b>data-province</b>. Necesitas poner un id por provincia (ej: id='madrid') o data-province='madrid'.</div>"
    );
    return;
  }

  // 3) Construir tablero: clonamos el SVG para tener slots (huecos) y piezas movibles
  // Creamos dos capas: board (slots) y pieces (movibles)
  const board = document.createElementNS("http://www.w3.org/2000/svg","g");
  board.setAttribute("id","board");
  const pieces = document.createElementNS("http://www.w3.org/2000/svg","g");
  pieces.setAttribute("id","pieces");

  // Limpiar contenido original y reconstruir
  const keep = []; // si tu SVG tiene cosas extra (texto, etc.), aqu√≠ podr√≠as preservarlas
  svg.innerHTML = "";
  svg.appendChild(board);
  svg.appendChild(pieces);
  keep.forEach(n => svg.appendChild(n));

  // Normalizamos cada provincia: slot (gris) y pieza (azul)
  const provinces = [];
  for (const original of provinceEls) {
    const prov = original.getAttribute("data-province");
    if(!prov) continue;

    // Slot
    const slot = original.cloneNode(true);
    slot.removeAttribute("id"); // evita ids duplicados
    slot.setAttribute("class","slot");
    slot.setAttribute("data-province", prov);
    board.appendChild(slot);

    // Pieza
    const piece = original.cloneNode(true);
    piece.removeAttribute("id");
    piece.setAttribute("class","piece");
    piece.setAttribute("data-province", prov);
    pieces.appendChild(piece);

    provinces.push(prov);
  }

  // Progreso
  TOTAL.textContent = String(provinces.length);
  PROG.textContent = "0";

  // Chips (solo visual)
  CHIPS.innerHTML = "";
  provinces.slice(0,80).forEach(p=>{
    const chip = document.createElement("div");
    chip.className = "chip";
    chip.textContent = p;
    CHIPS.appendChild(chip);
  });
  if(provinces.length > 80){
    const chip = document.createElement("div");
    chip.className = "chip";
    chip.textContent = `+${provinces.length-80} m√°s‚Ä¶`;
    CHIPS.appendChild(chip);
  }

  // 4) Poner las piezas ‚Äúfuera‚Äù del mapa (bandeja lateral simulada)
  // Las apilamos en una columna a la izquierda usando translate, para que no coincidan ya con el slot.
  function shufflePieces(){
    let i = 0;
    for (const el of pieces.querySelectorAll(".piece")) {
      if(el.classList.contains("placed")) continue;
      const b = el.getBBox();
      // Columna a la izquierda del mapa
      const x = (-b.x) + 20 + (i%2)*18;
      const y = (-b.y) + 20 + i*12;
      el.setAttribute("transform", `translate(${x}, ${y})`);
      i++;
    }
  }
  shufflePieces();

  // 5) Drag & Snap (Pointer Events)
  let active = null;
  let startPt = null;
  let startTranslate = {x:0,y:0};

  function svgPoint(evt){
    const p = svg.createSVGPoint();
    p.x = evt.clientX; p.y = evt.clientY;
    return p.matrixTransform(svg.getScreenCTM().inverse());
  }

  function parseTranslate(el){
    const t = el.getAttribute("transform") || "translate(0,0)";
    const m = /translate\(([-\d.]+)[ ,]([-\d.]+)\)/.exec(t);
    return {x: m?parseFloat(m[1]):0, y: m?parseFloat(m[2]):0};
  }

  function setTranslate(el,x,y){
    el.setAttribute("transform", `translate(${x}, ${y})`);
  }

  function centerOf(el){
    const b = el.getBBox();
    return {x: b.x + b.width/2, y: b.y + b.height/2, box: b};
  }

  function trySnap(piece){
    const prov = piece.getAttribute("data-province");
    const slot = board.querySelector(`.slot[data-province="${prov}"]`);
    if(!slot) return false;

    const pc = centerOf(piece);
    const sc = centerOf(slot);

    const dist = Math.hypot(pc.x - sc.x, pc.y - sc.y);
    if(dist > SNAP_DISTANCE) return false;

    // Alinear caja de pieza con caja del slot
    const dx = sc.box.x - pc.box.x;
    const dy = sc.box.y - pc.box.y;
    setTranslate(piece, dx, dy);

    piece.classList.add("placed");
    placed.add(prov);

    PROG.textContent = String(placed.size);
    if(placed.size === provinces.length) {
      alert("¬°Mapa completado! üéâ");
    }
    return true;
  }

  svg.addEventListener("pointerdown", (e) => {
    const target = e.target.closest?.(".piece");
    if(!target || target.classList.contains("placed")) return;

    active = target;
    active.classList.add("dragging");
    pieces.appendChild(active); // al frente

    startPt = svgPoint(e);
    startTranslate = parseTranslate(active);
    active.setPointerCapture?.(e.pointerId);
  });

  window.addEventListener("pointermove", (e) => {
    if(!active) return;
    const p = svgPoint(e);
    const dx = p.x - startPt.x;
    const dy = p.y - startPt.y;
    setTranslate(active, startTranslate.x + dx, startTranslate.y + dy);
  });

  window.addEventListener("pointerup", () => {
    if(!active) return;
    active.classList.remove("dragging");

    const snapped = trySnap(active);
    if(!snapped){
      // vuelve a ‚Äúbandeja‚Äù
      // (simple: vuelve a translate 0,0; si prefieres mantener la posici√≥n, quita esta l√≠nea)
      active.setAttribute("transform","translate(0,0)");
    }

    active = null;
  });

  // Botones
  document.getElementById("shuffle").onclick = shufflePieces;
  document.getElementById("reset").onclick = () => {
    placed.clear();
    PROG.textContent = "0";
    pieces.querySelectorAll(".piece").forEach(p=>{
      p.classList.remove("placed");
      p.setAttribute("transform","translate(0,0)");
    });
    shufflePieces();
  };
})();
</script>
</body>
</html>

