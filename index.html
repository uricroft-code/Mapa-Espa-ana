<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Espa√±a ‚Äî Puzzle por Comunidades (Provincias)</title>
  <style>
    body{margin:0;background:#f5f7ff;font-family:system-ui,sans-serif}
    .wrap{width:min(1400px,96vw);margin:0 auto;padding:16px}
    header{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{background:#eef2ff;border:1px solid #c7d2fe;border-radius:12px;padding:8px 12px;font-weight:900}
    button{border:0;border-radius:10px;padding:10px 12px;cursor:pointer;font-weight:900}
    .btn1{background:#f97316;color:#fff}
    .btn2{background:#ef4444;color:#fff}
    .btn3{background:#10b981;color:#fff}
    .btn4{background:#6366f1;color:#fff}
    .btn5{background:#111827;color:#fff}

    .grid{display:grid;grid-template-columns: 1fr 420px; gap:14px; margin-top:14px}
    @media (max-width: 1050px){ .grid{grid-template-columns:1fr} }

    .card{background:#fff;border-radius:16px;box-shadow:0 10px 25px rgba(0,0,0,.08);padding:12px}
    #stage{height:min(82vh,920px);border-radius:16px;overflow:hidden;position:relative}
    #stage svg{width:100%;height:100%;display:block;background:#fff}

    .hint{color:#374151;margin-top:10px;line-height:1.4}
    .ok{color:#16a34a;font-weight:900}
    .bad{color:#dc2626;font-weight:900}
    code{background:#f1f5f9;padding:2px 6px;border-radius:8px}

    .list{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;max-height:62vh;overflow:auto;padding-right:6px}
    .chip{
      border:1px solid #bfdbfe;background:#eff6ff;border-radius:999px;
      padding:8px 10px;font-size:12px;font-weight:900;
      cursor:pointer; user-select:none;
    }
    .chip.done{opacity:.55;text-decoration:line-through}

    .tooltip{
      position:absolute; pointer-events:none;
      background:rgba(17,24,39,.92); color:#fff;
      padding:8px 10px; border-radius:10px;
      font-weight:900; font-size:12px;
      display:none; z-index:10;
      transform:translate(10px,10px);
      max-width:260px;
    }

    /* MAPA */
    .prov-base{
      stroke:#fff; stroke-width:1; vector-effect:non-scaling-stroke;
      opacity:.30;
    }
    .prov-slot{
      fill:none;
      stroke:#111827; stroke-width:1.2; vector-effect:non-scaling-stroke;
      stroke-dasharray:7 6;
      pointer-events:none;
      opacity:.9;
    }
    .prov-slot.hint{
      stroke:#f59e0b; stroke-width:2.8; stroke-dasharray:0;
      opacity:1;
    }
    .piece{
      stroke:#111827; stroke-width:1.1; vector-effect:non-scaling-stroke;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,.18));
      cursor:grab; touch-action:none;
    }
    .piece.dragging{cursor:grabbing; opacity:.92}

    .label-prov{
      font-size:10px; font-weight:800; fill:#0b1220;
      paint-order:stroke; stroke:#fff; stroke-width:3px; stroke-linejoin:round;
      pointer-events:none; user-select:none;
    }
    .label-cc{
      font-size:18px; font-weight:900; fill:#111827; opacity:.88;
      paint-order:stroke; stroke:#fff; stroke-width:4px; stroke-linejoin:round;
      pointer-events:none; user-select:none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="pill">Comunidad: <span id="zone">‚Äî</span></div>
      <div class="pill">Progreso: <span id="prog">0</span>/<span id="total">0</span></div>
      <button class="btn1" id="shuffle">Mezclar bandeja</button>
      <button class="btn4" id="hintBtn">Pista</button>
      <button class="btn5" id="toggleLabels">Nombres: ON</button>
      <button class="btn2" id="reset">Reiniciar comunidad</button>
      <button class="btn3" id="next">Siguiente</button>
    </header>

    <div class="grid">
      <div class="card" id="stage">
        <div id="tip" class="tooltip"></div>
        <div id="loading" class="hint">Cargando mapa real (GeoJSON)‚Ä¶</div>
      </div>

      <div class="card">
        <b>Piezas disponibles (clic ‚Üí arrastrar)</b>
        <div id="status" class="hint"></div>
        <div class="hint">
          Haz click en una provincia para ‚Äúsacarla‚Äù como pieza y arr√°strala al mapa.
          Encaja sola si cae cerca del hueco.
        </div>
        <div class="list" id="chips"></div>
        <div class="hint">
          Archivos requeridos en el repo:
          <br>‚Äî <code>index.html</code>
          <br>‚Äî <code>espana-provincias.json</code>
        </div>
      </div>
    </div>
  </div>

  <!-- D3 (solo para dibujar/zoom/c√°lculos geom√©tricos) -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

<script>
(async function(){
  const STAGE  = document.getElementById("stage");
  const LOADING= document.getElementById("loading");
  const ZONE   = document.getElementById("zone");
  const PROG   = document.getElementById("prog");
  const TOTAL  = document.getElementById("total");
  const STATUS = document.getElementById("status");
  const CHIPS  = document.getElementById("chips");
  const TIP    = document.getElementById("tip");

  const BTN_SHUFFLE = document.getElementById("shuffle");
  const BTN_RESET   = document.getElementById("reset");
  const BTN_NEXT    = document.getElementById("next");
  const BTN_HINT    = document.getElementById("hintBtn");
  const BTN_LABELS  = document.getElementById("toggleLabels");

  const SNAP_DISTANCE = 40;

  const norm = (s) => (s||"")
    .toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
    .replace(/\s+/g," ")
    .trim();

  function hashToHue(str){
  let h = 0;
  for (let i=0;i<str.length;i++) h = (h*33 + str.charCodeAt(i)) >>> 0;
  return h % 360;
}

// Color base de comunidad (siempre el mismo para esa comunidad)
function colorCommunity(cc){
  const hue = hashToHue(cc);
  return { hue, sat: 68, light: 52 };
}

// Variaci√≥n por provincia dentro de su comunidad
function colorProvince(cc, provKey){
  const base = colorCommunity(cc);
  // variamos la luminosidad con el key de la provincia
  let k = 0;
  for (let i=0;i<provKey.length;i++) k = (k*29 + provKey.charCodeAt(i)) >>> 0;
  const delta = (k % 18) - 9;          // -9..+8
  const light = Math.max(38, Math.min(68, base.light + delta));
  return `hsl(${base.hue} ${base.sat}% ${light}%)`;
}

  }

  // Mapa provincia -> comunidad (por nombre normalizado)
  const PROV_TO_CC = new Map([
    ["a coruna","Galicia"],["lugo","Galicia"],["ourense","Galicia"],["pontevedra","Galicia"],
    ["asturias","Principado de Asturias"],["cantabria","Cantabria"],
    ["alava","Pa√≠s Vasco"],["gipuzkoa","Pa√≠s Vasco"],["bizkaia","Pa√≠s Vasco"],
    ["navarra","Navarra"],["la rioja","La Rioja"],
    ["huesca","Arag√≥n"],["teruel","Arag√≥n"],["zaragoza","Arag√≥n"],
    ["barcelona","Catalu√±a"],["girona","Catalu√±a"],["lleida","Catalu√±a"],["tarragona","Catalu√±a"],
    ["avila","Castilla y Le√≥n"],["burgos","Castilla y Le√≥n"],["leon","Castilla y Le√≥n"],["palencia","Castilla y Le√≥n"],["salamanca","Castilla y Le√≥n"],
    ["segovia","Castilla y Le√≥n"],["soria","Castilla y Le√≥n"],["valladolid","Castilla y Le√≥n"],["zamora","Castilla y Le√≥n"],
    ["madrid","Comunidad de Madrid"],
    ["albacete","Castilla-La Mancha"],["ciudad real","Castilla-La Mancha"],["cuenca","Castilla-La Mancha"],["guadalajara","Castilla-La Mancha"],["toledo","Castilla-La Mancha"],
    ["caceres","Extremadura"],["badajoz","Extremadura"],
    ["alicante","Comunidad Valenciana"],["castellon","Comunidad Valenciana"],["valencia","Comunidad Valenciana"],
    ["murcia","Regi√≥n de Murcia"],
    ["almeria","Andaluc√≠a"],["cadiz","Andaluc√≠a"],["cordoba","Andaluc√≠a"],["granada","Andaluc√≠a"],["huelva","Andaluc√≠a"],["jaen","Andaluc√≠a"],["malaga","Andaluc√≠a"],["sevilla","Andaluc√≠a"],
    ["illes balears","Illes Balears"],
    ["las palmas","Canarias"],["santa cruz de tenerife","Canarias"],
    ["ceuta","Ceuta"],["melilla","Melilla"]
  ]);

  const LEVELS = [
    "Galicia","Principado de Asturias","Cantabria","Pa√≠s Vasco","Navarra","La Rioja",
    "Arag√≥n","Catalu√±a","Castilla y Le√≥n","Comunidad de Madrid","Castilla-La Mancha",
    "Extremadura","Comunidad Valenciana","Regi√≥n de Murcia","Andaluc√≠a",
    "Illes Balears","Canarias","Ceuta","Melilla"
  ];

  // Obtener nombre ‚Äúrobusto‚Äù de un feature (depende del GeoJSON)
  function getProvName(props){
    const keys = ["name","nombre","provincia","province","NAME","NOMBRE","PROV","prov_name","texto"];
    for(const k of keys){
      if(props && props[k] && String(props[k]).trim()) return String(props[k]).trim();
    }
    // fallback: intenta la primera propiedad string que parezca nombre
    if(props){
      for(const [k,v] of Object.entries(props)){
        if(typeof v === "string" && v.length <= 40 && v.length >= 3) return v.trim();
      }
    }
    return "Provincia";
  }

  // Clave estable para provincia (sirve para color y tracking)
  function provKey(feature){
    return feature.id || feature.properties?.id || feature.properties?.code || feature.properties?.codigo || getProvName(feature.properties);
  }

  // ---- cargar GeoJSON local (repo) ----
  let geo;
  try{
    const res = await fetch("./espana-provincias.json");
    if(!res.ok) throw new Error("no ok");
    geo = await res.json();
  }catch(e){
    LOADING?.remove();
    STAGE.innerHTML = `<div class="bad">No puedo cargar <code>espana-provincias.json</code></div>
      <div class="hint">Crea ese archivo en tu repo (Add file ‚Üí Create new file) y pega dentro el GeoJSON.</div>`;
    return;
  }

  LOADING?.remove();

  // normalizar colecci√≥n
  const features = (geo.type === "FeatureCollection") ? geo.features
                 : (geo.type === "Feature") ? [geo]
                 : (Array.isArray(geo)) ? geo
                 : [];

  if(!features.length){
    STAGE.innerHTML = `<div class="bad">GeoJSON sin features</div>`;
    return;
  }

  // Catalogo provincias -> comunidad
  const catalog = features.map(f => {
    const name = getProvName(f.properties || {});
    const cc = PROV_TO_CC.get(norm(name)) || "OTRAS";
    return { feature:f, name, cc, key: String(provKey(f)) };
  }).filter(x => x.cc !== "OTRAS");

  STATUS.innerHTML = `<span class="ok">Provincias detectadas: ${catalog.length}</span>`;

  // ---- SVG + capas ----
  const svg = d3.select("#stage").append("svg");
  const gRoot   = svg.append("g");
  const gBase   = gRoot.append("g").attr("id","base");
  const gSlots  = gRoot.append("g").attr("id","slots");
  const gPlaced = gRoot.append("g").attr("id","placed");
  const gPieces = gRoot.append("g").attr("id","pieces");
  const gLabProv= gRoot.append("g").attr("id","labelsProv");
  const gLabCC  = gRoot.append("g").attr("id","labelsCC");

  // tooltip
  function showTip(text, ev){
    TIP.style.display = "block";
    TIP.textContent = text;
    const r = STAGE.getBoundingClientRect();
    TIP.style.left = (ev.clientX - r.left) + "px";
    TIP.style.top  = (ev.clientY - r.top) + "px";
  }
  function hideTip(){ TIP.style.display = "none"; }

  // Fit a pantalla (mapa entero)
  function fitProjection(){
    const w = document.getElementById("stage").clientWidth;
    const h = document.getElementById("stage").clientHeight;
    svg.attr("viewBox", `0 0 ${w} ${h}`);

    const projection = d3.geoMercator();
    projection.fitSize([w,h], {type:"FeatureCollection", features: catalog.map(d=>d.feature)});
    const path = d3.geoPath(projection);
    return {w,h,projection,path};
  }

  let {w,h,projection,path} = fitProjection();

  // zoom/pan
  const zoom = d3.zoom()
    .scaleExtent([1, 12])
    .on("zoom", (ev) => gRoot.attr("transform", ev.transform));
  svg.call(zoom).call(zoom.transform, d3.zoomIdentity); // start fit

  window.addEventListener("resize", () => {
    ({w,h,projection,path} = fitProjection());
    drawBase(); // recalcula paths
    renderLevel(); // reconstruye slots/labels/pieces para mantener consistencia
  });

  // Base map coloreado por provincia
  function drawBase(){
    const sel = gBase.selectAll("path").data(catalog, d=>d.key);
    sel.join(
      enter => enter.append("path")
        .attr("class","prov-base")
        .attr("data-key", d=>d.key)
        .attr("fill", d=>colorProvince(d.cc, d.key))
        .attr("d", d=>path(d.feature))
        .on("mousemove", (ev, d)=> showTip(d.name, ev))
        .on("mouseleave", hideTip),
      update => update.attr("d", d=>path(d.feature)),
      exit => exit.remove()
    );
  }
  drawBase();

  // ---- Juego por comunidades ----
  let levelIndex = 0;
  let activeList = [];
  let placed = new Set();
  let labelsOn = true;

  function clearHint(){
    gSlots.selectAll(".prov-slot").classed("hint", false);
  }

  function randomPending(){
    const pending = activeList.filter(p=>!placed.has(p.key));
    if(!pending.length) return null;
    return pending[Math.floor(Math.random()*pending.length)];
  }

  function buildLabels(){
    gLabProv.selectAll("*").remove();
    gLabCC.selectAll("*").remove();
    if(!labelsOn) return;

    // Provincias: solo comunidad actual (para no llenar todo)
    const provLabels = gLabProv.selectAll("text")
      .data(activeList, d=>d.key)
      .join("text")
      .attr("class","label-prov")
      .attr("text-anchor","middle")
      .attr("dominant-baseline","middle")
      .text(d=>d.name)
      .attr("x", d=>path.centroid(d.feature)[0])
      .attr("y", d=>path.centroid(d.feature)[1]);

    // Comunidad (una etiqueta grande centrada en el bounding box de su conjunto)
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    for(const p of activeList){
      const b = path.bounds(p.feature);
      minX = Math.min(minX, b[0][0]); minY = Math.min(minY, b[0][1]);
      maxX = Math.max(maxX, b[1][0]); maxY = Math.max(maxY, b[1][1]);
    }
    const ccName = LEVELS[levelIndex];
    gLabCC.append("text")
      .attr("class","label-cc")
      .attr("text-anchor","middle")
      .attr("dominant-baseline","middle")
      .attr("x", (minX+maxX)/2)
      .attr("y", (minY+maxY)/2)
      .text(ccName);
  }

  function renderChips(){
    CHIPS.innerHTML = "";
    for(const p of activeList){
      const chip = document.createElement("div");
      chip.className = "chip";
    const base = colorCommunity(p.cc);
chip.style.borderColor = `hsl(${base.hue} 80% 70%)`;
chip.style.background  = `hsl(${base.hue} 90% 96%)`;
chip.style.boxShadow   = `inset 0 0 0 2px hsl(${base.hue} 70% 70%)`;

      chip.dataset.key = p.key;
      if(placed.has(p.key)) chip.classList.add("done");
      chip.onclick = (ev)=> spawnPiece(p, ev);
      CHIPS.appendChild(chip);
    }
  }

  function renderSlots(){
    const sel = gSlots.selectAll("path").data(activeList, d=>d.key);
    sel.join(
      enter => enter.append("path")
        .attr("class","prov-slot")
        .attr("data-key", d=>d.key)
        .attr("d", d=>path(d.feature)),
      update => update.attr("d", d=>path(d.feature)),
      exit => exit.remove()
    );
  }

  function resetOpacityForLevel(){
    // baja opacidad base de la comunidad actual al iniciar
    gBase.selectAll("path").each(function(d){
      const el = d3.select(this);
      if(d.cc === LEVELS[levelIndex]) el.style("opacity", 0.18);
      else el.style("opacity", 0.30);
    });
  }

  function renderLevel(){
    placed = new Set();
    gPlaced.selectAll("*").remove();
    gPieces.selectAll("*").remove();
    clearHint();

    const cc = LEVELS[levelIndex];
    ZONE.textContent = cc;

    activeList = catalog.filter(p=>p.cc === cc);

    TOTAL.textContent = String(activeList.length);
    PROG.textContent = "0";

    renderSlots();
    renderChips();
    buildLabels();
    resetOpacityForLevel();
  }

  function nextLevel(){
    levelIndex++;
    if(levelIndex >= LEVELS.length){
      alert("¬°Espa√±a completada! üá™üá∏");
      levelIndex = 0;
    }
    renderLevel();
  }

  // ---- piezas (clic ‚Üí aparece ‚Üí arrastrar ‚Üí snap) ----
  let dragging = null;
  let draggingKey = null;
  let dragStart = null;
  let dragStartTransform = null;

  function getPointerInSvg(ev){
    const pt = svg.node().createSVGPoint();
    pt.x = ev.clientX; pt.y = ev.clientY;
    return pt.matrixTransform(svg.node().getScreenCTM().inverse());
  }

  function getTransform(node){
    const t = node.getAttribute("transform") || "translate(0,0)";
    const m = /translate\(([-\d.]+)[ ,]([-\d.]+)\)/.exec(t);
    return {x: m?+m[1]:0, y: m?+m[2]:0};
  }

  function setTransform(node, x, y){
    node.setAttribute("transform", `translate(${x},${y})`);
  }

  const pieceByKey = new Map();

  function spawnPiece(p, ev){
    if(placed.has(p.key)) return;

    let node = pieceByKey.get(p.key);
    if(!node){
      node = document.createElementNS("http://www.w3.org/2000/svg","path");
      node.setAttribute("class","piece");
      node.setAttribute("data-key", p.key);
      node.setAttribute("fill", colorProvince(p.cc, p.key));
      node.setAttribute("d", path(p.feature));
      gPieces.node().appendChild(node);
      pieceByKey.set(p.key, node);

      // aparece cerca del cursor
      const sp = getPointerInSvg(ev);
      const c = path.centroid(p.feature);
      setTransform(node, sp.x - c[0], sp.y - c[1]);
    }

    dragging = node;
    draggingKey = p.key;
    dragging.classList.add("dragging");
    dragStart = getPointerInSvg(ev);
    dragStartTransform = getTransform(dragging);
  }

  function trySnap(node, key){
    const p = activeList.find(x=>x.key===key);
    if(!p) return false;

    // centroides proyectados
    const target = path.centroid(p.feature); // [x,y] en pantalla SVG
    const current = (function(){
      // centroid del path sin transform, + transform actual
      const t = getTransform(node);
      const c0 = path.centroid(p.feature);
      return [c0[0] + t.x, c0[1] + t.y];
    })();

    const dist = Math.hypot(current[0]-target[0], current[1]-target[1]);
    if(dist > SNAP_DISTANCE) return false;

    // mover a posici√≥n exacta (transform = target - centroidBase)
    const baseC = path.centroid(p.feature);
    setTransform(node, target[0]-baseC[0], target[1]-baseC[1]);

    node.classList.remove("dragging");
    gPlaced.node().appendChild(node);

    placed.add(key);
    PROG.textContent = String(placed.size);

    // marcar chip
    const chip = CHIPS.querySelector(`.chip[data-key="${key}"]`);
    if(chip) chip.classList.add("done");

    // sube opacidad del base ya completado (o b√°jala m√°s, como prefieras)
    gBase.selectAll("path").each(function(d){
      if(d.key === key) d3.select(this).style("opacity", 0.08);
    });

    clearHint();
    if(placed.size === activeList.length){
      setTimeout(()=>{ alert(`¬°${ZONE.textContent} completada! üéâ`); nextLevel(); }, 120);
    }
    return true;
  }

  svg.on("pointerdown", (ev) => {
    const target = ev.target;
    if(!(target instanceof SVGPathElement)) return;
    if(!target.classList.contains("piece")) return;

    const key = target.getAttribute("data-key");
    if(!key || placed.has(key)) return;

    dragging = target;
    draggingKey = key;
    dragging.classList.add("dragging");
    dragStart = getPointerInSvg(ev);
    dragStartTransform = getTransform(dragging);
    target.setPointerCapture?.(ev.pointerId);
  });

  svg.on("pointermove", (ev) => {
    if(!dragging) return;
    const p = getPointerInSvg(ev);
    const dx = p.x - dragStart.x;
    const dy = p.y - dragStart.y;
    setTransform(dragging, dragStartTransform.x + dx, dragStartTransform.y + dy);
  });

  window.addEventListener("pointerup", () => {
    if(!dragging) return;
    trySnap(dragging, draggingKey);
    dragging.classList.remove("dragging");
    dragging = null;
    draggingKey = null;
  });

  // Botones
  BTN_HINT.onclick = () => {
    clearHint();
    const p = randomPending();
    if(!p) return;
    gSlots.selectAll("path").each(function(d){
      if(d.key === p.key) d3.select(this).classed("hint", true);
    });
  };

  BTN_SHUFFLE.onclick = () => {
    const items = Array.from(CHIPS.children);
    for(let i=items.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      CHIPS.insertBefore(items[j], items[i]);
    }
  };

  BTN_RESET.onclick = () => renderLevel();
  BTN_NEXT.onclick = () => nextLevel();

  BTN_LABELS.onclick = () => {
    labelsOn = !labelsOn;
    BTN_LABELS.textContent = `Nombres: ${labelsOn ? "ON" : "OFF"}`;
    buildLabels();
  };

  // Start
  renderLevel();
})();
</script>
</body>
</html>
